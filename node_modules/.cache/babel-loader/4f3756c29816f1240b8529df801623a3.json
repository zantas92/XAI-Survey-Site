{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\n\nfunction parseProxyResponse(socket) {\n  return new Promise((resolve, reject) => {\n    // we need to buffer any HTTP traffic that happens with the proxy before we get\n    // the CONNECT response, so that if the response is anything other than an \"200\"\n    // response code, then we can re-play the \"data\" events on the socket once the\n    // HTTP parser is hooked up...\n    let buffersLength = 0;\n    const buffers = [];\n\n    function read() {\n      const b = socket.read();\n      if (b) ondata(b);else socket.once('readable', read);\n    }\n\n    function cleanup() {\n      socket.removeListener('end', onend);\n      socket.removeListener('error', onerror);\n      socket.removeListener('close', onclose);\n      socket.removeListener('readable', read);\n    }\n\n    function onclose(err) {\n      debug('onclose had error %o', err);\n    }\n\n    function onend() {\n      debug('onend');\n    }\n\n    function onerror(err) {\n      cleanup();\n      debug('onerror %o', err);\n      reject(err);\n    }\n\n    function ondata(b) {\n      buffers.push(b);\n      buffersLength += b.length;\n      const buffered = Buffer.concat(buffers, buffersLength);\n      const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n\n      if (endOfHeaders === -1) {\n        // keep buffering\n        debug('have not received end of HTTP headers yet...');\n        read();\n        return;\n      }\n\n      const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n      const statusCode = +firstLine.split(' ')[1];\n      debug('got proxy server response: %o', firstLine);\n      resolve({\n        statusCode,\n        buffered\n      });\n    }\n\n    socket.on('error', onerror);\n    socket.on('close', onclose);\n    socket.on('end', onend);\n    read();\n  });\n}\n\nexports.default = parseProxyResponse;","map":{"version":3,"mappings":";;;;;;;;;;;;AAAA;;AAGA,MAAMA,KAAK,GAAGC,gBAAY,wCAAZ,CAAd;;AAOA,SAAwBC,kBAAxB,CACCC,MADD,EACiB;AAEhB,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;AACtC;AACA;AACA;AACA;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,UAAMC,OAAO,GAAa,EAA1B;;AAEA,aAASC,IAAT,GAAa;AACZ,YAAMC,CAAC,GAAGP,MAAM,CAACM,IAAP,EAAV;AACA,UAAIC,CAAJ,EAAOC,MAAM,CAACD,CAAD,CAAN,CAAP,KACKP,MAAM,CAACS,IAAP,CAAY,UAAZ,EAAwBH,IAAxB;AACL;;AAED,aAASI,OAAT,GAAgB;AACfV,YAAM,CAACW,cAAP,CAAsB,KAAtB,EAA6BC,KAA7B;AACAZ,YAAM,CAACW,cAAP,CAAsB,OAAtB,EAA+BE,OAA/B;AACAb,YAAM,CAACW,cAAP,CAAsB,OAAtB,EAA+BG,OAA/B;AACAd,YAAM,CAACW,cAAP,CAAsB,UAAtB,EAAkCL,IAAlC;AACA;;AAED,aAASQ,OAAT,CAAiBC,GAAjB,EAA4B;AAC3BlB,WAAK,CAAC,sBAAD,EAAyBkB,GAAzB,CAAL;AACA;;AAED,aAASH,KAAT,GAAc;AACbf,WAAK,CAAC,OAAD,CAAL;AACA;;AAED,aAASgB,OAAT,CAAiBE,GAAjB,EAA2B;AAC1BL,aAAO;AACPb,WAAK,CAAC,YAAD,EAAekB,GAAf,CAAL;AACAZ,YAAM,CAACY,GAAD,CAAN;AACA;;AAED,aAASP,MAAT,CAAgBD,CAAhB,EAAyB;AACxBF,aAAO,CAACW,IAAR,CAAaT,CAAb;AACAH,mBAAa,IAAIG,CAAC,CAACU,MAAnB;AAEA,YAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAcf,OAAd,EAAuBD,aAAvB,CAAjB;AACA,YAAMiB,YAAY,GAAGH,QAAQ,CAACI,OAAT,CAAiB,UAAjB,CAArB;;AAEA,UAAID,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACxB;AACAxB,aAAK,CAAC,8CAAD,CAAL;AACAS,YAAI;AACJ;AACA;;AAED,YAAMiB,SAAS,GAAGL,QAAQ,CAACM,QAAT,CACjB,OADiB,EAEjB,CAFiB,EAGjBN,QAAQ,CAACI,OAAT,CAAiB,MAAjB,CAHiB,CAAlB;AAKA,YAAMG,UAAU,GAAG,CAACF,SAAS,CAACG,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAApB;AACA7B,WAAK,CAAC,+BAAD,EAAkC0B,SAAlC,CAAL;AACArB,aAAO,CAAC;AACPuB,kBADO;AAEPP;AAFO,OAAD,CAAP;AAIA;;AAEDlB,UAAM,CAAC2B,EAAP,CAAU,OAAV,EAAmBd,OAAnB;AACAb,UAAM,CAAC2B,EAAP,CAAU,OAAV,EAAmBb,OAAnB;AACAd,UAAM,CAAC2B,EAAP,CAAU,KAAV,EAAiBf,KAAjB;AAEAN,QAAI;AACJ,GAnEM,CAAP;AAoEA;;AAvEDsB","names":["debug","debug_1","parseProxyResponse","socket","Promise","resolve","reject","buffersLength","buffers","read","b","ondata","once","cleanup","removeListener","onend","onerror","onclose","err","push","length","buffered","Buffer","concat","endOfHeaders","indexOf","firstLine","toString","statusCode","split","on","exports"],"sources":["../src/parse-proxy-response.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}