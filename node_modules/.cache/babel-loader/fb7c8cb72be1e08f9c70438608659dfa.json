{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs = require(\"fs\");\n\nconst gcpMetadata = require(\"gcp-metadata\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst isbrowser_1 = require(\"../isbrowser\");\n\nconst messages = require(\"../messages\");\n\nconst transporters_1 = require(\"../transporters\");\n\nconst computeclient_1 = require(\"./computeclient\");\n\nconst envDetect_1 = require(\"./envDetect\");\n\nconst jwtclient_1 = require(\"./jwtclient\");\n\nconst refreshclient_1 = require(\"./refreshclient\");\n\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nclass GoogleAuth {\n  constructor(opts) {\n    /**\n     * Caches a value indicating whether the auth layer is running on Google\n     * Compute Engine.\n     * @private\n     */\n    this.checkIsGCE = undefined; // To save the contents of the JSON credential file\n\n    this.jsonContent = null;\n    this.cachedCredential = null;\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n    this.clientOptions = opts.clientOptions;\n  } // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n\n\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n\n  getDefaultProjectId(callback) {\n    messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  getProjectId(callback) {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  getProjectIdAsync() {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    } // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n\n\n    if (!this._getDefaultProjectIdPromise) {\n      this._getDefaultProjectIdPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const projectId = this.getProductionProjectId() || (yield this.getFileProjectId()) || (yield this.getDefaultServiceProjectId()) || (yield this.getGCEProjectId());\n          this._cachedProjectId = projectId;\n          resolve(projectId);\n        } catch (e) {\n          reject(e);\n        }\n      }));\n    }\n\n    return this._getDefaultProjectIdPromise;\n  }\n\n  getApplicationDefault() {\n    let optionsOrCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let callback = arguments.length > 1 ? arguments[1] : undefined;\n    let options;\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  getApplicationDefaultAsync(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // If we've already got a cached credential, just return it.\n      if (this.cachedCredential) {\n        return {\n          credential: this.cachedCredential,\n          projectId: yield this.getProjectIdAsync()\n        };\n      }\n\n      let credential;\n      let projectId; // Check for the existence of a local environment variable pointing to the\n      // location of the credential file. This is typically used in local\n      // developer scenarios.\n\n      credential = yield this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n\n      if (credential) {\n        if (credential instanceof jwtclient_1.JWT) {\n          credential.scopes = this.scopes;\n        }\n\n        this.cachedCredential = credential;\n        projectId = yield this.getProjectId();\n        return {\n          credential,\n          projectId\n        };\n      } // Look in the well-known credential file location.\n\n\n      credential = yield this._tryGetApplicationCredentialsFromWellKnownFile(options);\n\n      if (credential) {\n        if (credential instanceof jwtclient_1.JWT) {\n          credential.scopes = this.scopes;\n        }\n\n        this.cachedCredential = credential;\n        projectId = yield this.getProjectId();\n        return {\n          credential,\n          projectId\n        };\n      } // Determine if we're running on GCE.\n\n\n      let isGCE;\n\n      try {\n        isGCE = yield this._checkIsGCE();\n      } catch (e) {\n        throw new Error('Unexpected error determining execution environment: ' + e.message);\n      }\n\n      if (!isGCE) {\n        // We failed to find the default credentials. Bail out with an error.\n        throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n      } // For GCE, just return a default ComputeClient. It will take care of\n      // the rest.\n\n\n      this.cachedCredential = new computeclient_1.Compute(options);\n      projectId = yield this.getProjectId();\n      return {\n        projectId,\n        credential: this.cachedCredential\n      };\n    });\n  }\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n\n\n  _checkIsGCE() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.checkIsGCE === undefined) {\n        this.checkIsGCE = yield gcpMetadata.isAvailable();\n      }\n\n      return this.checkIsGCE;\n    });\n  }\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n\n\n  _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] || process.env['google_application_credentials'];\n\n      if (!credentialsPath || credentialsPath.length === 0) {\n        return null;\n      }\n\n      try {\n        return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n      } catch (e) {\n        throw this.createError('Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.', e);\n      }\n    });\n  }\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n\n\n  _tryGetApplicationCredentialsFromWellKnownFile(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // First, figure out the location of the file, depending upon the OS type.\n      let location = null;\n\n      if (this._isWindows()) {\n        // Windows\n        location = process.env['APPDATA'];\n      } else {\n        // Linux or Mac\n        const home = process.env['HOME'];\n\n        if (home) {\n          location = this._pathJoin(home, '.config');\n        }\n      } // If we found the root path, expand it.\n\n\n      if (location) {\n        location = this._pathJoin(location, 'gcloud');\n        location = this._pathJoin(location, 'application_default_credentials.json');\n        location = this._mockWellKnownFilePath(location); // Check whether the file exists.\n\n        if (!this._fileExists(location)) {\n          location = null;\n        }\n      } // The file does not exist.\n\n\n      if (!location) {\n        return null;\n      } // The file seems to exist. Try to use it.\n\n\n      const client = yield this._getApplicationCredentialsFromFilePath(location, options);\n      this.warnOnProblematicCredentials(client);\n      return client;\n    });\n  }\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n\n\n  _getApplicationCredentialsFromFilePath(filePath) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      // Make sure the path looks like a string.\n      if (!filePath || filePath.length === 0) {\n        throw new Error('The file path is invalid.');\n      } // Make sure there is a file at the path. lstatSync will throw if there is\n      // nothing there.\n\n\n      try {\n        // Resolve path to actual file in case of symlink. Expect a thrown error\n        // if not resolvable.\n        filePath = fs.realpathSync(filePath);\n\n        if (!fs.lstatSync(filePath).isFile()) {\n          throw new Error();\n        }\n      } catch (err) {\n        throw this.createError(`The file at ${filePath} does not exist, or it is not a file.`, err);\n      } // Now open a read stream on the file, and parse it.\n\n\n      try {\n        const readStream = this._createReadStream(filePath);\n\n        return this.fromStream(readStream, options);\n      } catch (err) {\n        throw this.createError(`Unable to read the file at ${filePath}.`, err);\n      }\n    });\n  }\n  /**\n   * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n   * are problematic because they may not have APIs enabled and have limited\n   * quota. If this is the case, warn about it.\n   */\n\n\n  warnOnProblematicCredentials(client) {\n    if (client.email === exports.CLOUD_SDK_CLIENT_ID) {\n      messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n    }\n  }\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @param options The JWT or UserRefresh options for the client\n   * @returns JWT or UserRefresh Client with data\n   */\n\n\n  fromJSON(json, options) {\n    let client;\n\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing the Google auth settings.');\n    }\n\n    this.jsonContent = json;\n    options = options || {};\n\n    if (json.type === 'authorized_user') {\n      client = new refreshclient_1.UserRefreshClient(options);\n    } else {\n      options.scopes = this.scopes;\n      client = new jwtclient_1.JWT(options);\n    }\n\n    client.fromJSON(json);\n    return client;\n  }\n\n  fromStream(inputStream) {\n    let optionsOrCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let callback = arguments.length > 2 ? arguments[2] : undefined;\n    let options = {};\n\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n\n    if (callback) {\n      this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  fromStreamAsync(inputStream, options) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error('Must pass in a stream containing the Google auth settings.');\n      }\n\n      let s = '';\n      inputStream.setEncoding('utf8').on('error', reject).on('data', chunk => s += chunk).on('end', () => {\n        try {\n          const data = JSON.parse(s);\n          const r = this.fromJSON(data, options);\n          return resolve(r);\n        } catch (err) {\n          return reject(err);\n        }\n      });\n    });\n  }\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n\n\n  fromAPIKey(apiKey, options) {\n    options = options || {};\n    const client = new jwtclient_1.JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n\n\n  _isWindows() {\n    const sys = this._osPlatform();\n\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Creates a file stream. Allows mocking.\n   * @api private\n   */\n\n\n  _createReadStream(filePath) {\n    return fs.createReadStream(filePath);\n  }\n  /**\n   * Gets the current operating system platform. Allows mocking.\n   * @api private\n   */\n\n\n  _osPlatform() {\n    return os.platform();\n  }\n  /**\n   * Determines whether a file exists. Allows mocking.\n   * @api private\n   */\n\n\n  _fileExists(filePath) {\n    return fs.existsSync(filePath);\n  }\n  /**\n   * Joins two parts of a path. Allows mocking.\n   * @api private\n   */\n\n\n  _pathJoin(item1, item2) {\n    return path.join(item1, item2);\n  }\n  /**\n   * Allows mocking of the path to a well-known file.\n   * @api private\n   */\n\n\n  _mockWellKnownFilePath(filePath) {\n    return filePath;\n  } // Creates an Error containing the given message, and includes the message\n  // from the optional err passed in.\n\n\n  createError(message, err) {\n    let s = message || '';\n\n    if (err) {\n      const errorMessage = String(err);\n\n      if (errorMessage && errorMessage.length > 0) {\n        if (s.length > 0) {\n          s += ' ';\n        }\n\n        s += errorMessage;\n      }\n    }\n\n    return Error(s);\n  }\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n\n\n  getDefaultServiceProjectId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise(resolve => {\n        child_process_1.exec('gcloud config config-helper --format json', (err, stdout, stderr) => {\n          if (!err && stdout) {\n            try {\n              const projectId = JSON.parse(stdout).configuration.properties.core.project;\n              resolve(projectId);\n              return;\n            } catch (e) {// ignore errors\n            }\n          }\n\n          resolve(null);\n        });\n      });\n    });\n  }\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n\n\n  getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] || process.env['google_cloud_project'];\n  }\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n\n\n  getFileProjectId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.cachedCredential) {\n        // Try to read the project ID from the cached credentials file\n        return this.cachedCredential.projectId;\n      } // Ensure the projectId is loaded from the keyFile if available.\n\n\n      if (this.keyFilename) {\n        const creds = yield this.getClient();\n\n        if (creds && creds.projectId) {\n          return creds.projectId;\n        }\n      } // Try to load a credentials file and read its project ID\n\n\n      const r = yield this._tryGetApplicationCredentialsFromEnvironmentVariable();\n\n      if (r) {\n        return r.projectId;\n      } else {\n        return null;\n      }\n    });\n  }\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n\n\n  getGCEProjectId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const r = yield gcpMetadata.project('project-id');\n        return r;\n      } catch (e) {\n        // Ignore any errors\n        return null;\n      }\n    });\n  }\n\n  getCredentials(callback) {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  getCredentialsAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.getClient();\n\n      if (this.jsonContent) {\n        const credential = {\n          client_email: this.jsonContent.client_email,\n          private_key: this.jsonContent.private_key\n        };\n        return credential;\n      }\n\n      const isGCE = yield this._checkIsGCE();\n\n      if (!isGCE) {\n        throw new Error('Unknown error.');\n      } // For GCE, return the service account details from the metadata server\n      // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n      // The GCF metadata server doesn't respect querystring params if this / is\n      // not included.\n\n\n      const data = yield gcpMetadata.instance({\n        property: 'service-accounts/',\n        params: {\n          recursive: 'true'\n        }\n      });\n\n      if (!data || !data.default || !data.default.email) {\n        throw new Error('Failure from metadata server.');\n      }\n\n      return {\n        client_email: data.default.email\n      };\n    });\n  }\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n\n\n  getClient(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (options) {\n        this.keyFilename = options.keyFilename || options.keyFile || this.keyFilename;\n        this.scopes = options.scopes || this.scopes;\n        this.jsonContent = options.credentials || this.jsonContent;\n        this.clientOptions = options.clientOptions;\n      }\n\n      if (!this.cachedCredential) {\n        if (this.jsonContent) {\n          this.cachedCredential = yield this.fromJSON(this.jsonContent, this.clientOptions);\n        } else if (this.keyFilename) {\n          const filePath = path.resolve(this.keyFilename);\n          const stream = fs.createReadStream(filePath);\n          this.cachedCredential = yield this.fromStreamAsync(stream, this.clientOptions);\n        } else {\n          yield this.getApplicationDefaultAsync(this.clientOptions);\n        }\n      }\n\n      return this.cachedCredential;\n    });\n  }\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n\n\n  getAccessToken() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = yield this.getClient();\n      return (yield client.getAccessToken()).token;\n    });\n  }\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n\n\n  getRequestHeaders(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = yield this.getClient();\n      return client.getRequestHeaders(url);\n    });\n  }\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n\n\n  authorizeRequest(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      opts = opts || {};\n      const url = opts.url || opts.uri;\n      const client = yield this.getClient();\n      const headers = yield client.getRequestHeaders(url);\n      opts.headers = Object.assign(opts.headers || {}, headers);\n      return opts;\n    });\n  }\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // tslint:disable-next-line no-any\n\n\n  request(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = yield this.getClient();\n      return client.request(opts);\n    });\n  }\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n\n\n  getEnv() {\n    return envDetect_1.getEnv();\n  }\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n\n\n  sign(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const client = yield this.getClient();\n      const crypto = crypto_1.createCrypto();\n\n      if (client instanceof jwtclient_1.JWT && client.key && !isbrowser_1.isBrowser()) {\n        const sign = crypto.createSign('RSA-SHA256');\n        sign.update(data);\n        return sign.sign(client.key, 'base64');\n      }\n\n      const projectId = yield this.getProjectId();\n\n      if (!projectId) {\n        throw new Error('Cannot sign data without a project ID.');\n      }\n\n      const creds = yield this.getCredentials();\n\n      if (!creds.client_email) {\n        throw new Error('Cannot sign data without `client_email`.');\n      }\n\n      const id = `projects/${projectId}/serviceAccounts/${creds.client_email}`;\n      const res = yield this.request({\n        method: 'POST',\n        url: `https://iam.googleapis.com/v1/${id}:signBlob`,\n        data: {\n          bytesToSign: crypto.encodeBase64StringUtf8(data)\n        }\n      });\n      return res.data.signature;\n    });\n  }\n\n}\n/**\n * Export DefaultTransporter as a static property of the class.\n */\n\n\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\nexports.GoogleAuth = GoogleAuth;","map":{"version":3,"sources":["D:/Kurser/Exjobb/Enkät/Release/xai-survey-app/node_modules/googleapis-common/node_modules/google-auth-library/build/src/auth/googleauth.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","child_process_1","require","fs","gcpMetadata","os","path","crypto_1","isbrowser_1","messages","transporters_1","computeclient_1","envDetect_1","jwtclient_1","refreshclient_1","CLOUD_SDK_CLIENT_ID","GoogleAuth","constructor","opts","checkIsGCE","undefined","jsonContent","cachedCredential","_cachedProjectId","projectId","keyFilename","keyFile","scopes","credentials","clientOptions","isGCE","getDefaultProjectId","callback","warn","DEFAULT_PROJECT_ID_DEPRECATED","getProjectIdAsync","r","getProjectId","_getDefaultProjectIdPromise","getProductionProjectId","getFileProjectId","getDefaultServiceProjectId","getGCEProjectId","getApplicationDefault","optionsOrCallback","options","getApplicationDefaultAsync","credential","_tryGetApplicationCredentialsFromEnvironmentVariable","JWT","_tryGetApplicationCredentialsFromWellKnownFile","_checkIsGCE","Error","message","Compute","isAvailable","credentialsPath","process","env","length","_getApplicationCredentialsFromFilePath","createError","location","_isWindows","home","_pathJoin","_mockWellKnownFilePath","_fileExists","client","warnOnProblematicCredentials","filePath","realpathSync","lstatSync","isFile","err","readStream","_createReadStream","fromStream","email","PROBLEMATIC_CREDENTIALS_WARNING","fromJSON","json","type","UserRefreshClient","inputStream","fromStreamAsync","s","setEncoding","on","chunk","data","JSON","parse","fromAPIKey","apiKey","sys","_osPlatform","substring","toLowerCase","createReadStream","platform","existsSync","item1","item2","join","errorMessage","String","exec","stdout","stderr","configuration","properties","core","project","creds","getClient","getCredentials","getCredentialsAsync","client_email","private_key","instance","property","params","recursive","default","stream","getAccessToken","token","getRequestHeaders","url","authorizeRequest","uri","headers","assign","request","getEnv","sign","crypto","createCrypto","key","isBrowser","createSign","update","id","res","method","bytesToSign","encodeBase64StringUtf8","signature","DefaultTransporter"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst child_process_1 = require(\"child_process\");\nconst fs = require(\"fs\");\nconst gcpMetadata = require(\"gcp-metadata\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst isbrowser_1 = require(\"../isbrowser\");\nconst messages = require(\"../messages\");\nconst transporters_1 = require(\"../transporters\");\nconst computeclient_1 = require(\"./computeclient\");\nconst envDetect_1 = require(\"./envDetect\");\nconst jwtclient_1 = require(\"./jwtclient\");\nconst refreshclient_1 = require(\"./refreshclient\");\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nclass GoogleAuth {\n    constructor(opts) {\n        /**\n         * Caches a value indicating whether the auth layer is running on Google\n         * Compute Engine.\n         * @private\n         */\n        this.checkIsGCE = undefined;\n        // To save the contents of the JSON credential file\n        this.jsonContent = null;\n        this.cachedCredential = null;\n        opts = opts || {};\n        this._cachedProjectId = opts.projectId || null;\n        this.keyFilename = opts.keyFilename || opts.keyFile;\n        this.scopes = opts.scopes;\n        this.jsonContent = opts.credentials || null;\n        this.clientOptions = opts.clientOptions;\n    }\n    // Note:  this properly is only public to satisify unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n    get isGCE() {\n        return this.checkIsGCE;\n    }\n    getDefaultProjectId(callback) {\n        messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n        if (callback) {\n            this.getProjectIdAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getProjectIdAsync();\n        }\n    }\n    getProjectId(callback) {\n        if (callback) {\n            this.getProjectIdAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getProjectIdAsync();\n        }\n    }\n    getProjectIdAsync() {\n        if (this._cachedProjectId) {\n            return Promise.resolve(this._cachedProjectId);\n        }\n        // In implicit case, supports three environments. In order of precedence,\n        // the implicit environments are:\n        // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n        // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n        // - Cloud SDK: `gcloud config config-helper --format json`\n        // - GCE project ID from metadata server)\n        if (!this._getDefaultProjectIdPromise) {\n            this._getDefaultProjectIdPromise =\n                new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    try {\n                        const projectId = this.getProductionProjectId() ||\n                            (yield this.getFileProjectId()) ||\n                            (yield this.getDefaultServiceProjectId()) ||\n                            (yield this.getGCEProjectId());\n                        this._cachedProjectId = projectId;\n                        resolve(projectId);\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                }));\n        }\n        return this._getDefaultProjectIdPromise;\n    }\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n        let options;\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n        }\n        else {\n            return this.getApplicationDefaultAsync(options);\n        }\n    }\n    getApplicationDefaultAsync(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If we've already got a cached credential, just return it.\n            if (this.cachedCredential) {\n                return {\n                    credential: this.cachedCredential,\n                    projectId: yield this.getProjectIdAsync()\n                };\n            }\n            let credential;\n            let projectId;\n            // Check for the existence of a local environment variable pointing to the\n            // location of the credential file. This is typically used in local\n            // developer scenarios.\n            credential =\n                yield this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n            if (credential) {\n                if (credential instanceof jwtclient_1.JWT) {\n                    credential.scopes = this.scopes;\n                }\n                this.cachedCredential = credential;\n                projectId = yield this.getProjectId();\n                return { credential, projectId };\n            }\n            // Look in the well-known credential file location.\n            credential =\n                yield this._tryGetApplicationCredentialsFromWellKnownFile(options);\n            if (credential) {\n                if (credential instanceof jwtclient_1.JWT) {\n                    credential.scopes = this.scopes;\n                }\n                this.cachedCredential = credential;\n                projectId = yield this.getProjectId();\n                return { credential, projectId };\n            }\n            // Determine if we're running on GCE.\n            let isGCE;\n            try {\n                isGCE = yield this._checkIsGCE();\n            }\n            catch (e) {\n                throw new Error('Unexpected error determining execution environment: ' + e.message);\n            }\n            if (!isGCE) {\n                // We failed to find the default credentials. Bail out with an error.\n                throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n            }\n            // For GCE, just return a default ComputeClient. It will take care of\n            // the rest.\n            this.cachedCredential = new computeclient_1.Compute(options);\n            projectId = yield this.getProjectId();\n            return { projectId, credential: this.cachedCredential };\n        });\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */\n    _checkIsGCE() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.checkIsGCE === undefined) {\n                this.checkIsGCE = yield gcpMetadata.isAvailable();\n            }\n            return this.checkIsGCE;\n        });\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\n                process.env['google_application_credentials'];\n            if (!credentialsPath || credentialsPath.length === 0) {\n                return null;\n            }\n            try {\n                return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n            }\n            catch (e) {\n                throw this.createError('Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.', e);\n            }\n        });\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    _tryGetApplicationCredentialsFromWellKnownFile(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // First, figure out the location of the file, depending upon the OS type.\n            let location = null;\n            if (this._isWindows()) {\n                // Windows\n                location = process.env['APPDATA'];\n            }\n            else {\n                // Linux or Mac\n                const home = process.env['HOME'];\n                if (home) {\n                    location = this._pathJoin(home, '.config');\n                }\n            }\n            // If we found the root path, expand it.\n            if (location) {\n                location = this._pathJoin(location, 'gcloud');\n                location =\n                    this._pathJoin(location, 'application_default_credentials.json');\n                location = this._mockWellKnownFilePath(location);\n                // Check whether the file exists.\n                if (!this._fileExists(location)) {\n                    location = null;\n                }\n            }\n            // The file does not exist.\n            if (!location) {\n                return null;\n            }\n            // The file seems to exist. Try to use it.\n            const client = yield this._getApplicationCredentialsFromFilePath(location, options);\n            this.warnOnProblematicCredentials(client);\n            return client;\n        });\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */\n    _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Make sure the path looks like a string.\n            if (!filePath || filePath.length === 0) {\n                throw new Error('The file path is invalid.');\n            }\n            // Make sure there is a file at the path. lstatSync will throw if there is\n            // nothing there.\n            try {\n                // Resolve path to actual file in case of symlink. Expect a thrown error\n                // if not resolvable.\n                filePath = fs.realpathSync(filePath);\n                if (!fs.lstatSync(filePath).isFile()) {\n                    throw new Error();\n                }\n            }\n            catch (err) {\n                throw this.createError(`The file at ${filePath} does not exist, or it is not a file.`, err);\n            }\n            // Now open a read stream on the file, and parse it.\n            try {\n                const readStream = this._createReadStream(filePath);\n                return this.fromStream(readStream, options);\n            }\n            catch (err) {\n                throw this.createError(`Unable to read the file at ${filePath}.`, err);\n            }\n        });\n    }\n    /**\n     * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n     * are problematic because they may not have APIs enabled and have limited\n     * quota. If this is the case, warn about it.\n     */\n    warnOnProblematicCredentials(client) {\n        if (client.email === exports.CLOUD_SDK_CLIENT_ID) {\n            messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n        }\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromJSON(json, options) {\n        let client;\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the Google auth settings.');\n        }\n        this.jsonContent = json;\n        options = options || {};\n        if (json.type === 'authorized_user') {\n            client = new refreshclient_1.UserRefreshClient(options);\n        }\n        else {\n            options.scopes = this.scopes;\n            client = new jwtclient_1.JWT(options);\n        }\n        client.fromJSON(json);\n        return client;\n    }\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.fromStreamAsync(inputStream, options)\n                .then(r => callback(null, r), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream, options);\n        }\n    }\n    fromStreamAsync(inputStream, options) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                throw new Error('Must pass in a stream containing the Google auth settings.');\n            }\n            let s = '';\n            inputStream.setEncoding('utf8')\n                .on('error', reject)\n                .on('data', (chunk) => s += chunk)\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    const r = this.fromJSON(data, options);\n                    return resolve(r);\n                }\n                catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */\n    fromAPIKey(apiKey, options) {\n        options = options || {};\n        const client = new jwtclient_1.JWT(options);\n        client.fromAPIKey(apiKey);\n        return client;\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */\n    _isWindows() {\n        const sys = this._osPlatform();\n        if (sys && sys.length >= 3) {\n            if (sys.substring(0, 3).toLowerCase() === 'win') {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Creates a file stream. Allows mocking.\n     * @api private\n     */\n    _createReadStream(filePath) {\n        return fs.createReadStream(filePath);\n    }\n    /**\n     * Gets the current operating system platform. Allows mocking.\n     * @api private\n     */\n    _osPlatform() {\n        return os.platform();\n    }\n    /**\n     * Determines whether a file exists. Allows mocking.\n     * @api private\n     */\n    _fileExists(filePath) {\n        return fs.existsSync(filePath);\n    }\n    /**\n     * Joins two parts of a path. Allows mocking.\n     * @api private\n     */\n    _pathJoin(item1, item2) {\n        return path.join(item1, item2);\n    }\n    /**\n     * Allows mocking of the path to a well-known file.\n     * @api private\n     */\n    _mockWellKnownFilePath(filePath) {\n        return filePath;\n    }\n    // Creates an Error containing the given message, and includes the message\n    // from the optional err passed in.\n    createError(message, err) {\n        let s = message || '';\n        if (err) {\n            const errorMessage = String(err);\n            if (errorMessage && errorMessage.length > 0) {\n                if (s.length > 0) {\n                    s += ' ';\n                }\n                s += errorMessage;\n            }\n        }\n        return Error(s);\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */\n    getDefaultServiceProjectId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise(resolve => {\n                child_process_1.exec('gcloud config config-helper --format json', (err, stdout, stderr) => {\n                    if (!err && stdout) {\n                        try {\n                            const projectId = JSON.parse(stdout).configuration.properties.core.project;\n                            resolve(projectId);\n                            return;\n                        }\n                        catch (e) {\n                            // ignore errors\n                        }\n                    }\n                    resolve(null);\n                });\n            });\n        });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */\n    getProductionProjectId() {\n        return process.env['GCLOUD_PROJECT'] ||\n            process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] ||\n            process.env['google_cloud_project'];\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */\n    getFileProjectId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.cachedCredential) {\n                // Try to read the project ID from the cached credentials file\n                return this.cachedCredential.projectId;\n            }\n            // Ensure the projectId is loaded from the keyFile if available.\n            if (this.keyFilename) {\n                const creds = yield this.getClient();\n                if (creds && creds.projectId) {\n                    return creds.projectId;\n                }\n            }\n            // Try to load a credentials file and read its project ID\n            const r = yield this._tryGetApplicationCredentialsFromEnvironmentVariable();\n            if (r) {\n                return r.projectId;\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */\n    getGCEProjectId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const r = yield gcpMetadata.project('project-id');\n                return r;\n            }\n            catch (e) {\n                // Ignore any errors\n                return null;\n            }\n        });\n    }\n    getCredentials(callback) {\n        if (callback) {\n            this.getCredentialsAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getCredentialsAsync();\n        }\n    }\n    getCredentialsAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getClient();\n            if (this.jsonContent) {\n                const credential = {\n                    client_email: this.jsonContent.client_email,\n                    private_key: this.jsonContent.private_key\n                };\n                return credential;\n            }\n            const isGCE = yield this._checkIsGCE();\n            if (!isGCE) {\n                throw new Error('Unknown error.');\n            }\n            // For GCE, return the service account details from the metadata server\n            // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n            // The GCF metadata server doesn't respect querystring params if this / is\n            // not included.\n            const data = yield gcpMetadata.instance({ property: 'service-accounts/', params: { recursive: 'true' } });\n            if (!data || !data.default || !data.default.email) {\n                throw new Error('Failure from metadata server.');\n            }\n            return { client_email: data.default.email };\n        });\n    }\n    /**\n     * Automatically obtain a client based on the provided configuration.  If no\n     * options were passed, use Application Default Credentials.\n     */\n    getClient(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (options) {\n                this.keyFilename =\n                    options.keyFilename || options.keyFile || this.keyFilename;\n                this.scopes = options.scopes || this.scopes;\n                this.jsonContent = options.credentials || this.jsonContent;\n                this.clientOptions = options.clientOptions;\n            }\n            if (!this.cachedCredential) {\n                if (this.jsonContent) {\n                    this.cachedCredential =\n                        yield this.fromJSON(this.jsonContent, this.clientOptions);\n                }\n                else if (this.keyFilename) {\n                    const filePath = path.resolve(this.keyFilename);\n                    const stream = fs.createReadStream(filePath);\n                    this.cachedCredential =\n                        yield this.fromStreamAsync(stream, this.clientOptions);\n                }\n                else {\n                    yield this.getApplicationDefaultAsync(this.clientOptions);\n                }\n            }\n            return this.cachedCredential;\n        });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */\n    getAccessToken() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = yield this.getClient();\n            return (yield client.getAccessToken()).token;\n        });\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */\n    getRequestHeaders(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = yield this.getClient();\n            return client.getRequestHeaders(url);\n        });\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */\n    authorizeRequest(opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            opts = opts || {};\n            const url = opts.url || opts.uri;\n            const client = yield this.getClient();\n            const headers = yield client.getRequestHeaders(url);\n            opts.headers = Object.assign(opts.headers || {}, headers);\n            return opts;\n        });\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */\n    // tslint:disable-next-line no-any\n    request(opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = yield this.getClient();\n            return client.request(opts);\n        });\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */\n    getEnv() {\n        return envDetect_1.getEnv();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     */\n    sign(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = yield this.getClient();\n            const crypto = crypto_1.createCrypto();\n            if (client instanceof jwtclient_1.JWT && client.key && !isbrowser_1.isBrowser()) {\n                const sign = crypto.createSign('RSA-SHA256');\n                sign.update(data);\n                return sign.sign(client.key, 'base64');\n            }\n            const projectId = yield this.getProjectId();\n            if (!projectId) {\n                throw new Error('Cannot sign data without a project ID.');\n            }\n            const creds = yield this.getCredentials();\n            if (!creds.client_email) {\n                throw new Error('Cannot sign data without `client_email`.');\n            }\n            const id = `projects/${projectId}/serviceAccounts/${creds.client_email}`;\n            const res = yield this.request({\n                method: 'POST',\n                url: `https://iam.googleapis.com/v1/${id}:signBlob`,\n                data: { bytesToSign: crypto.encodeBase64StringUtf8(data) }\n            });\n            return res.data.signature;\n        });\n    }\n}\n/**\n * Export DefaultTransporter as a static property of the class.\n */\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\nexports.GoogleAuth = GoogleAuth;\n//# sourceMappingURL=googleauth.js.map"]},"metadata":{},"sourceType":"script"}