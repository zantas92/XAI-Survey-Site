{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst querystring = require(\"querystring\");\n\nconst stream = require(\"stream\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst isbrowser_1 = require(\"../isbrowser\");\n\nconst messages = require(\"../messages\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar CertificateFormat;\n\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\n\nclass OAuth2Client extends authclient_1.AuthClient {\n  constructor(optionsOrClientId, clientSecret, redirectUri) {\n    super();\n    this.certificateCache = {};\n    this.certificateExpiry = null;\n    this.certificateCacheFormat = CertificateFormat.PEM;\n    this.refreshTokenPromises = new Map();\n    const opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret,\n      redirectUri\n    };\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n\n\n  generateAuthUrl() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n    }\n\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  generateCodeVerifier() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n  }\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n\n\n  generateCodeVerifierAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // base64 encoding uses 6 bits per character, and we want to generate128\n      // characters. 6*128/8 = 96.\n      const crypto = crypto_1.createCrypto();\n      const randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n      // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n      // swapping out a few chars.\n\n      const codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n      const unencodedCodeChallenge = yield crypto.sha256DigestBase64(codeVerifier); // We need to use base64UrlEncoding instead of standard base64\n\n      const codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n      return {\n        codeVerifier,\n        codeChallenge\n      };\n    });\n  }\n\n  getToken(codeOrOptions, callback) {\n    const options = typeof codeOrOptions === 'string' ? {\n      code: codeOrOptions\n    } : codeOrOptions;\n\n    if (callback) {\n      this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  getTokenAsync(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n      const values = {\n        code: options.code,\n        client_id: options.client_id || this._clientId,\n        client_secret: this._clientSecret,\n        redirect_uri: options.redirect_uri || this.redirectUri,\n        grant_type: 'authorization_code',\n        code_verifier: options.codeVerifier\n      };\n      const res = yield this.transporter.request({\n        method: 'POST',\n        url,\n        data: querystring.stringify(values),\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n      const tokens = res.data;\n\n      if (res.data && res.data.expires_in) {\n        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n        delete tokens.expires_in;\n      }\n\n      this.emit('tokens', tokens);\n      return {\n        tokens,\n        res\n      };\n    });\n  }\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n\n\n  refreshToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!refreshToken) {\n        return this.refreshTokenNoCache(refreshToken);\n      } // If a request to refresh using the same token has started,\n      // return the same promise.\n\n\n      if (this.refreshTokenPromises.has(refreshToken)) {\n        return this.refreshTokenPromises.get(refreshToken);\n      }\n\n      const p = this.refreshTokenNoCache(refreshToken).then(r => {\n        this.refreshTokenPromises.delete(refreshToken);\n        return r;\n      }, e => {\n        this.refreshTokenPromises.delete(refreshToken);\n        throw e;\n      });\n      this.refreshTokenPromises.set(refreshToken, p);\n      return p;\n    });\n  }\n\n  refreshTokenNoCache(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n      const data = {\n        refresh_token: refreshToken,\n        client_id: this._clientId,\n        client_secret: this._clientSecret,\n        grant_type: 'refresh_token'\n      }; // request for new token\n\n      const res = yield this.transporter.request({\n        method: 'POST',\n        url,\n        data: querystring.stringify(data),\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n      const tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n      if (res.data && res.data.expires_in) {\n        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n        delete tokens.expires_in;\n      }\n\n      this.emit('tokens', tokens);\n      return {\n        tokens,\n        res\n      };\n    });\n  }\n\n  refreshAccessToken(callback) {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n\n    if (callback) {\n      this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  refreshAccessTokenAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = yield this.refreshToken(this.credentials.refresh_token);\n      const tokens = r.tokens;\n      tokens.refresh_token = this.credentials.refresh_token;\n      this.credentials = tokens;\n      return {\n        credentials: this.credentials,\n        res: r.res\n      };\n    });\n  }\n\n  getAccessToken(callback) {\n    if (callback) {\n      this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  getAccessTokenAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n\n      if (shouldRefresh) {\n        if (!this.credentials.refresh_token) {\n          throw new Error('No refresh token is set.');\n        }\n\n        const r = yield this.refreshAccessTokenAsync();\n\n        if (!r.credentials || r.credentials && !r.credentials.access_token) {\n          throw new Error('Could not refresh access token.');\n        }\n\n        return {\n          token: r.credentials.access_token,\n          res: r.res\n        };\n      } else {\n        return {\n          token: this.credentials.access_token\n        };\n      }\n    });\n  }\n\n  getRequestMetadata(url, callback) {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   * @param url The optional url being authorized\n   */\n\n\n  getRequestHeaders(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const res = yield this.getRequestMetadataAsync(url);\n      return res.headers;\n    });\n  }\n\n  getRequestMetadataAsync(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const thisCreds = this.credentials;\n\n      if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n        throw new Error('No access, refresh token or API key is set.');\n      }\n\n      if (thisCreds.access_token && !this.isTokenExpiring()) {\n        thisCreds.token_type = thisCreds.token_type || 'Bearer';\n        const headers = {\n          Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n        };\n        return {\n          headers\n        };\n      }\n\n      if (this.apiKey) {\n        return {\n          headers: {}\n        };\n      }\n\n      let r = null;\n      let tokens = null;\n\n      try {\n        r = yield this.refreshToken(thisCreds.refresh_token);\n        tokens = r.tokens;\n      } catch (err) {\n        const e = err;\n\n        if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n          e.message = 'Could not refresh access token.';\n        }\n\n        throw e;\n      }\n\n      const credentials = this.credentials;\n      credentials.token_type = credentials.token_type || 'Bearer';\n      tokens.refresh_token = credentials.refresh_token;\n      this.credentials = tokens;\n      const headers = {\n        Authorization: credentials.token_type + ' ' + tokens.access_token\n      };\n      return {\n        headers,\n        res: r.res\n      };\n    });\n  }\n  /**\n   * Generates an URL to revoke the given token.\n   * @param token The existing token to be revoked.\n   */\n\n\n  static getRevokeTokenUrl(token) {\n    const parameters = querystring.stringify({\n      token\n    });\n    return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n  }\n\n  revokeToken(token, callback) {\n    const opts = {\n      url: OAuth2Client.getRevokeTokenUrl(token),\n      method: 'POST'\n    };\n\n    if (callback) {\n      this.transporter.request(opts).then(r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n  revokeCredentials(callback) {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  revokeCredentialsAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const token = this.credentials.access_token;\n      this.credentials = {};\n\n      if (token) {\n        return this.revokeToken(token);\n      } else {\n        throw new Error('No access token to revoke.');\n      }\n    });\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  requestAsync(opts) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      let r2;\n\n      try {\n        const r = yield this.getRequestMetadataAsync(opts.url);\n\n        if (r.headers && r.headers.Authorization) {\n          opts.headers = opts.headers || {};\n          opts.headers.Authorization = r.headers.Authorization;\n        }\n\n        if (this.apiKey) {\n          opts.params = Object.assign(opts.params || {}, {\n            key: this.apiKey\n          });\n        }\n\n        r2 = yield this.transporter.request(opts);\n      } catch (e) {\n        const res = e.response;\n\n        if (res) {\n          const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - An access_token and refresh_token were available, but no\n          //   expiry_date was availabe. This can happen when developers stash\n          //   the access_token and refresh_token for later use, but the\n          //   access_token fails on the first try because it's expired.\n\n          const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && !this.credentials.expiry_date;\n          const isReadableStream = res.config.data instanceof stream.Readable;\n          const isAuthErr = statusCode === 401 || statusCode === 403;\n\n          if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n            yield this.refreshAccessTokenAsync();\n            return this.requestAsync(opts, true);\n          }\n        }\n\n        throw e;\n      }\n\n      return r2;\n    });\n  }\n\n  verifyIdToken(options, callback) {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  verifyIdTokenAsync(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!options.idToken) {\n        throw new Error('The verifyIdToken method requires an ID Token');\n      }\n\n      const response = yield this.getFederatedSignonCertsAsync();\n      const login = yield this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n      return login;\n    });\n  }\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n\n\n  getTokenInfo(accessToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data\n      } = yield this.transporter.request({\n        method: 'GET',\n        url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n        params: {\n          access_token: accessToken\n        }\n      });\n      const info = Object.assign({\n        expiry_date: new Date().getTime() + data.expires_in * 1000,\n        scopes: data.scope.split(' ')\n      }, data);\n      delete info.expires_in;\n      delete info.scope;\n      return info;\n    });\n  }\n\n  getFederatedSignonCerts(callback) {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  getFederatedSignonCertsAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const nowTime = new Date().getTime();\n      const format = isbrowser_1.isBrowser() ? CertificateFormat.JWK : CertificateFormat.PEM;\n\n      if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {\n        return {\n          certs: this.certificateCache,\n          format\n        };\n      }\n\n      let res;\n      let url;\n\n      switch (format) {\n        case CertificateFormat.PEM:\n          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n          break;\n\n        case CertificateFormat.JWK:\n          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n          break;\n\n        default:\n          throw new Error(`Unsupported certificate format ${format}`);\n      }\n\n      try {\n        res = yield this.transporter.request({\n          url\n        });\n      } catch (e) {\n        throw new Error('Failed to retrieve verification certificates: ' + e);\n      }\n\n      const cacheControl = res ? res.headers['cache-control'] : undefined;\n      let cacheAge = -1;\n\n      if (cacheControl) {\n        const pattern = new RegExp('max-age=([0-9]*)');\n        const regexResult = pattern.exec(cacheControl);\n\n        if (regexResult && regexResult.length === 2) {\n          // Cache results with max-age (in seconds)\n          cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n        }\n      }\n\n      let certificates = {};\n\n      switch (format) {\n        case CertificateFormat.PEM:\n          certificates = res.data;\n          break;\n\n        case CertificateFormat.JWK:\n          for (const key of res.data.keys) {\n            certificates[key.kid] = key;\n          }\n\n          break;\n\n        default:\n          throw new Error(`Unsupported certificate format ${format}`);\n      }\n\n      const now = new Date();\n      this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n      this.certificateCache = certificates;\n      this.certificateCacheFormat = format;\n      return {\n        certs: certificates,\n        format,\n        res\n      };\n    });\n  }\n\n  verifySignedJwtWithCerts() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n  }\n  /**\n   * Verify the id token is signed with the correct certificate\n   * and is from the correct audience.\n   * @param jwt The jwt to verify (The ID Token in this case).\n   * @param certs The array of certs to test the jwt against.\n   * @param requiredAudience The audience to test the jwt against.\n   * @param issuers The allowed issuers of the jwt (Optional).\n   * @param maxExpiry The max expiry the certificate can be (Optional).\n   * @return Returns a promise resolving to LoginTicket on verification.\n   */\n\n\n  verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const crypto = crypto_1.createCrypto();\n\n      if (!maxExpiry) {\n        maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n      }\n\n      const segments = jwt.split('.');\n\n      if (segments.length !== 3) {\n        throw new Error('Wrong number of segments in token: ' + jwt);\n      }\n\n      const signed = segments[0] + '.' + segments[1];\n      const signature = segments[2];\n      let envelope;\n      let payload;\n\n      try {\n        envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n      } catch (err) {\n        throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n      }\n\n      if (!envelope) {\n        throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n      }\n\n      try {\n        payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n      } catch (err) {\n        throw new Error('Can\\'t parse token payload: ' + segments[0]);\n      }\n\n      if (!payload) {\n        throw new Error('Can\\'t parse token payload: ' + segments[1]);\n      }\n\n      if (!certs.hasOwnProperty(envelope.kid)) {\n        // If this is not present, then there's no reason to attempt verification\n        throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n      }\n\n      const cert = certs[envelope.kid];\n      const verified = yield crypto.verify(cert, signed, signature);\n\n      if (!verified) {\n        throw new Error('Invalid token signature: ' + jwt);\n      }\n\n      if (!payload.iat) {\n        throw new Error('No issue time in token: ' + JSON.stringify(payload));\n      }\n\n      if (!payload.exp) {\n        throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n      }\n\n      const iat = Number(payload.iat);\n      if (isNaN(iat)) throw new Error('iat field using invalid format');\n      const exp = Number(payload.exp);\n      if (isNaN(exp)) throw new Error('exp field using invalid format');\n      const now = new Date().getTime() / 1000;\n\n      if (exp >= now + maxExpiry) {\n        throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n      }\n\n      const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n      const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n      if (now < earliest) {\n        throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n      }\n\n      if (now > latest) {\n        throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n      }\n\n      if (issuers && issuers.indexOf(payload.iss) < 0) {\n        throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n      } // Check the audience matches if we have one\n\n\n      if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n        const aud = payload.aud;\n        let audVerified = false; // If the requiredAudience is an array, check if it contains token\n        // audience\n\n        if (requiredAudience.constructor === Array) {\n          audVerified = requiredAudience.indexOf(aud) > -1;\n        } else {\n          audVerified = aud === requiredAudience;\n        }\n\n        if (!audVerified) {\n          throw new Error('Wrong recipient, payload audience != requiredAudience');\n        }\n      }\n\n      return new loginticket_1.LoginTicket(envelope, payload);\n    });\n  }\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n\n\n  isTokenExpiring() {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n  }\n\n}\n\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Clock skew - five minutes in seconds\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\nexports.OAuth2Client = OAuth2Client;","map":{"version":3,"sources":["D:/Kurser/Exjobb/Enkät/Release/xai-survey-app/node_modules/googleapis-common/node_modules/google-auth-library/build/src/auth/oauth2client.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","querystring","require","stream","crypto_1","isbrowser_1","messages","authclient_1","loginticket_1","CodeChallengeMethod","CertificateFormat","OAuth2Client","AuthClient","constructor","optionsOrClientId","clientSecret","redirectUri","certificateCache","certificateExpiry","certificateCacheFormat","PEM","refreshTokenPromises","Map","opts","clientId","_clientId","_clientSecret","eagerRefreshThresholdMillis","generateAuthUrl","code_challenge_method","code_challenge","Error","response_type","client_id","redirect_uri","scope","Array","join","rootUrl","GOOGLE_OAUTH2_AUTH_BASE_URL_","stringify","generateCodeVerifier","generateCodeVerifierAsync","crypto","createCrypto","randomString","randomBytesBase64","codeVerifier","replace","unencodedCodeChallenge","sha256DigestBase64","codeChallenge","split","getToken","codeOrOptions","callback","options","code","getTokenAsync","r","tokens","res","response","url","GOOGLE_OAUTH2_TOKEN_URL_","values","client_secret","grant_type","code_verifier","transporter","request","method","data","headers","expires_in","expiry_date","Date","getTime","emit","refreshToken","refreshTokenNoCache","has","get","p","delete","set","refresh_token","refreshAccessToken","warn","REFRESH_ACCESS_TOKEN_DEPRECATED","refreshAccessTokenAsync","credentials","getAccessToken","getAccessTokenAsync","token","shouldRefresh","access_token","isTokenExpiring","getRequestMetadata","OAUTH_GET_REQUEST_METADATA_DEPRECATED","getRequestMetadataAsync","getRequestHeaders","thisCreds","apiKey","token_type","Authorization","err","status","message","getRevokeTokenUrl","parameters","GOOGLE_OAUTH2_REVOKE_URL_","revokeToken","revokeCredentials","revokeCredentialsAsync","requestAsync","retry","r2","params","assign","key","statusCode","mayRequireRefresh","isReadableStream","config","Readable","isAuthErr","verifyIdToken","verifyIdTokenAsync","idToken","getFederatedSignonCertsAsync","login","verifySignedJwtWithCertsAsync","certs","audience","ISSUERS_","maxExpiry","getTokenInfo","accessToken","GOOGLE_TOKEN_INFO_URL","info","scopes","getFederatedSignonCerts","nowTime","format","isBrowser","JWK","GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_","GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_","cacheControl","undefined","cacheAge","pattern","RegExp","regexResult","exec","length","Number","certificates","keys","kid","now","verifySignedJwtWithCerts","jwt","requiredAudience","issuers","MAX_TOKEN_LIFETIME_SECS_","segments","signed","signature","envelope","payload","JSON","parse","decodeBase64StringUtf8","hasOwnProperty","cert","verified","verify","iat","exp","isNaN","earliest","CLOCK_SKEW_SECS_","latest","indexOf","iss","aud","audVerified","LoginTicket","expiryDate"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst isbrowser_1 = require(\"../isbrowser\");\nconst messages = require(\"../messages\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\n        super();\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n            optionsOrClientId :\n            { clientId: optionsOrClientId, clientSecret, redirectUri };\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.eagerRefreshThresholdMillis =\n            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n    generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n        }\n        opts.response_type = opts.response_type || 'code';\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (opts.scope instanceof Array) {\n            opts.scope = opts.scope.join(' ');\n        }\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n        return rootUrl + '?' + querystring.stringify(opts);\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and it's\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     */\n    generateCodeVerifierAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // base64 encoding uses 6 bits per character, and we want to generate128\n            // characters. 6*128/8 = 96.\n            const crypto = crypto_1.createCrypto();\n            const randomString = crypto.randomBytesBase64(96);\n            // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n            // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n            // swapping out a few chars.\n            const codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n            // Generate the base64 encoded SHA256\n            const unencodedCodeChallenge = yield crypto.sha256DigestBase64(codeVerifier);\n            // We need to use base64UrlEncoding instead of standard base64\n            const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                .replace(/\\+/g, '-')\n                .replace(/\\//g, '_');\n            return { codeVerifier, codeChallenge };\n        });\n    }\n    getToken(codeOrOptions, callback) {\n        const options = (typeof codeOrOptions === 'string') ?\n            { code: codeOrOptions } :\n            codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n        }\n        else {\n            return this.getTokenAsync(options);\n        }\n    }\n    getTokenAsync(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            const values = {\n                code: options.code,\n                client_id: options.client_id || this._clientId,\n                client_secret: this._clientSecret,\n                redirect_uri: options.redirect_uri || this.redirectUri,\n                grant_type: 'authorization_code',\n                code_verifier: options.codeVerifier\n            };\n            const res = yield this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(values),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n            });\n            const tokens = res.data;\n            if (res.data && res.data.expires_in) {\n                tokens.expiry_date =\n                    ((new Date()).getTime() + (res.data.expires_in * 1000));\n                delete tokens.expires_in;\n            }\n            this.emit('tokens', tokens);\n            return { tokens, res };\n        });\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n    refreshToken(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!refreshToken) {\n                return this.refreshTokenNoCache(refreshToken);\n            }\n            // If a request to refresh using the same token has started,\n            // return the same promise.\n            if (this.refreshTokenPromises.has(refreshToken)) {\n                return this.refreshTokenPromises.get(refreshToken);\n            }\n            const p = this.refreshTokenNoCache(refreshToken)\n                .then(r => {\n                this.refreshTokenPromises.delete(refreshToken);\n                return r;\n            }, e => {\n                this.refreshTokenPromises.delete(refreshToken);\n                throw e;\n            });\n            this.refreshTokenPromises.set(refreshToken, p);\n            return p;\n        });\n    }\n    refreshTokenNoCache(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            const data = {\n                refresh_token: refreshToken,\n                client_id: this._clientId,\n                client_secret: this._clientSecret,\n                grant_type: 'refresh_token'\n            };\n            // request for new token\n            const res = yield this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(data),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n            });\n            const tokens = res.data;\n            // TODO: de-duplicate this code from a few spots\n            if (res.data && res.data.expires_in) {\n                tokens.expiry_date =\n                    ((new Date()).getTime() + (res.data.expires_in * 1000));\n                delete tokens.expires_in;\n            }\n            this.emit('tokens', tokens);\n            return { tokens, res };\n        });\n    }\n    refreshAccessToken(callback) {\n        messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n        if (callback) {\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n        }\n        else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    refreshAccessTokenAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.credentials.refresh_token) {\n                throw new Error('No refresh token is set.');\n            }\n            const r = yield this.refreshToken(this.credentials.refresh_token);\n            const tokens = r.tokens;\n            tokens.refresh_token = this.credentials.refresh_token;\n            this.credentials = tokens;\n            return { credentials: this.credentials, res: r.res };\n        });\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n        }\n        else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    getAccessTokenAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n            if (shouldRefresh) {\n                if (!this.credentials.refresh_token) {\n                    throw new Error('No refresh token is set.');\n                }\n                const r = yield this.refreshAccessTokenAsync();\n                if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                    throw new Error('Could not refresh access token.');\n                }\n                return { token: r.credentials.access_token, res: r.res };\n            }\n            else {\n                return { token: this.credentials.access_token };\n            }\n        });\n    }\n    getRequestMetadata(url, callback) {\n        messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n        if (callback) {\n            this.getRequestMetadataAsync(url).then(r => callback(null, r.headers, r.res), callback);\n        }\n        else {\n            return this.getRequestMetadataAsync();\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n    getRequestHeaders(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = yield this.getRequestMetadataAsync(url);\n            return res.headers;\n        });\n    }\n    getRequestMetadataAsync(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const thisCreds = this.credentials;\n            if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n                throw new Error('No access, refresh token or API key is set.');\n            }\n            if (thisCreds.access_token && !this.isTokenExpiring()) {\n                thisCreds.token_type = thisCreds.token_type || 'Bearer';\n                const headers = {\n                    Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n                };\n                return { headers };\n            }\n            if (this.apiKey) {\n                return { headers: {} };\n            }\n            let r = null;\n            let tokens = null;\n            try {\n                r = yield this.refreshToken(thisCreds.refresh_token);\n                tokens = r.tokens;\n            }\n            catch (err) {\n                const e = err;\n                if (e.response &&\n                    (e.response.status === 403 || e.response.status === 404)) {\n                    e.message = 'Could not refresh access token.';\n                }\n                throw e;\n            }\n            const credentials = this.credentials;\n            credentials.token_type = credentials.token_type || 'Bearer';\n            tokens.refresh_token = credentials.refresh_token;\n            this.credentials = tokens;\n            const headers = {\n                Authorization: credentials.token_type + ' ' + tokens.access_token\n            };\n            return { headers, res: r.res };\n        });\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n    static getRevokeTokenUrl(token) {\n        const parameters = querystring.stringify({ token });\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: OAuth2Client.getRevokeTokenUrl(token),\n            method: 'POST'\n        };\n        if (callback) {\n            this.transporter.request(opts).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n        }\n        else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    revokeCredentialsAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const token = this.credentials.access_token;\n            this.credentials = {};\n            if (token) {\n                return this.revokeToken(token);\n            }\n            else {\n                throw new Error('No access token to revoke.');\n            }\n        });\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    requestAsync(opts, retry = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let r2;\n            try {\n                const r = yield this.getRequestMetadataAsync(opts.url);\n                if (r.headers && r.headers.Authorization) {\n                    opts.headers = opts.headers || {};\n                    opts.headers.Authorization = r.headers.Authorization;\n                }\n                if (this.apiKey) {\n                    opts.params = Object.assign(opts.params || {}, { key: this.apiKey });\n                }\n                r2 = yield this.transporter.request(opts);\n            }\n            catch (e) {\n                const res = e.response;\n                if (res) {\n                    const statusCode = res.status;\n                    // Retry the request for metadata if the following criteria are true:\n                    // - We haven't already retried.  It only makes sense to retry once.\n                    // - The response was a 401 or a 403\n                    // - The request didn't send a readableStream\n                    // - An access_token and refresh_token were available, but no\n                    //   expiry_date was availabe. This can happen when developers stash\n                    //   the access_token and refresh_token for later use, but the\n                    //   access_token fails on the first try because it's expired.\n                    const mayRequireRefresh = this.credentials &&\n                        this.credentials.access_token && this.credentials.refresh_token &&\n                        !this.credentials.expiry_date;\n                    const isReadableStream = res.config.data instanceof stream.Readable;\n                    const isAuthErr = statusCode === 401 || statusCode === 403;\n                    if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                        yield this.refreshAccessTokenAsync();\n                        return this.requestAsync(opts, true);\n                    }\n                }\n                throw e;\n            }\n            return r2;\n        });\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== 'function') {\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    verifyIdTokenAsync(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!options.idToken) {\n                throw new Error('The verifyIdToken method requires an ID Token');\n            }\n            const response = yield this.getFederatedSignonCertsAsync();\n            const login = yield this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n            return login;\n        });\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n    getTokenInfo(accessToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data } = yield this.transporter.request({\n                method: 'GET',\n                url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n                params: { access_token: accessToken }\n            });\n            const info = Object.assign({\n                expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n                scopes: data.scope.split(' ')\n            }, data);\n            delete info.expires_in;\n            delete info.scope;\n            return info;\n        });\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n        }\n        else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    getFederatedSignonCertsAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const nowTime = (new Date()).getTime();\n            const format = isbrowser_1.isBrowser() ? CertificateFormat.JWK : CertificateFormat.PEM;\n            if (this.certificateExpiry &&\n                (nowTime < this.certificateExpiry.getTime()) &&\n                this.certificateCacheFormat === format) {\n                return { certs: this.certificateCache, format };\n            }\n            let res;\n            let url;\n            switch (format) {\n                case CertificateFormat.PEM:\n                    url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                    break;\n                case CertificateFormat.JWK:\n                    url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                    break;\n                default:\n                    throw new Error(`Unsupported certificate format ${format}`);\n            }\n            try {\n                res = yield this.transporter.request({ url });\n            }\n            catch (e) {\n                throw new Error('Failed to retrieve verification certificates: ' + e);\n            }\n            const cacheControl = res ? res.headers['cache-control'] : undefined;\n            let cacheAge = -1;\n            if (cacheControl) {\n                const pattern = new RegExp('max-age=([0-9]*)');\n                const regexResult = pattern.exec(cacheControl);\n                if (regexResult && regexResult.length === 2) {\n                    // Cache results with max-age (in seconds)\n                    cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n                }\n            }\n            let certificates = {};\n            switch (format) {\n                case CertificateFormat.PEM:\n                    certificates = res.data;\n                    break;\n                case CertificateFormat.JWK:\n                    for (const key of res.data.keys) {\n                        certificates[key.kid] = key;\n                    }\n                    break;\n                default:\n                    throw new Error(`Unsupported certificate format ${format}`);\n            }\n            const now = new Date();\n            this.certificateExpiry =\n                cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n            this.certificateCache = certificates;\n            this.certificateCacheFormat = format;\n            return { certs: certificates, format, res };\n        });\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n    verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const crypto = crypto_1.createCrypto();\n            if (!maxExpiry) {\n                maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n            }\n            const segments = jwt.split('.');\n            if (segments.length !== 3) {\n                throw new Error('Wrong number of segments in token: ' + jwt);\n            }\n            const signed = segments[0] + '.' + segments[1];\n            const signature = segments[2];\n            let envelope;\n            let payload;\n            try {\n                envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n            }\n            catch (err) {\n                throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n            }\n            if (!envelope) {\n                throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n            }\n            try {\n                payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n            }\n            catch (err) {\n                throw new Error('Can\\'t parse token payload: ' + segments[0]);\n            }\n            if (!payload) {\n                throw new Error('Can\\'t parse token payload: ' + segments[1]);\n            }\n            if (!certs.hasOwnProperty(envelope.kid)) {\n                // If this is not present, then there's no reason to attempt verification\n                throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n            }\n            const cert = certs[envelope.kid];\n            const verified = yield crypto.verify(cert, signed, signature);\n            if (!verified) {\n                throw new Error('Invalid token signature: ' + jwt);\n            }\n            if (!payload.iat) {\n                throw new Error('No issue time in token: ' + JSON.stringify(payload));\n            }\n            if (!payload.exp) {\n                throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n            }\n            const iat = Number(payload.iat);\n            if (isNaN(iat))\n                throw new Error('iat field using invalid format');\n            const exp = Number(payload.exp);\n            if (isNaN(exp))\n                throw new Error('exp field using invalid format');\n            const now = new Date().getTime() / 1000;\n            if (exp >= now + maxExpiry) {\n                throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n            }\n            const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n            const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n            if (now < earliest) {\n                throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' +\n                    JSON.stringify(payload));\n            }\n            if (now > latest) {\n                throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' +\n                    JSON.stringify(payload));\n            }\n            if (issuers && issuers.indexOf(payload.iss) < 0) {\n                throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' +\n                    payload.iss);\n            }\n            // Check the audience matches if we have one\n            if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n                const aud = payload.aud;\n                let audVerified = false;\n                // If the requiredAudience is an array, check if it contains token\n                // audience\n                if (requiredAudience.constructor === Array) {\n                    audVerified = (requiredAudience.indexOf(aud) > -1);\n                }\n                else {\n                    audVerified = (aud === requiredAudience);\n                }\n                if (!audVerified) {\n                    throw new Error('Wrong recipient, payload audience != requiredAudience');\n                }\n            }\n            return new loginticket_1.LoginTicket(envelope, payload);\n        });\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n    isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate ? expiryDate <=\n            ((new Date()).getTime() + this.eagerRefreshThresholdMillis) :\n            false;\n    }\n}\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\nexports.OAuth2Client = OAuth2Client;\n//# sourceMappingURL=oauth2client.js.map"]},"metadata":{},"sourceType":"script"}